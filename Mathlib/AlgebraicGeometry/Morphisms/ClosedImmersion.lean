/-
Copyright (c) 2023 Jonas van der Schaaf. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Amelia Livingston, Christian Merten, Jonas van der Schaaf
-/
import Mathlib.AlgebraicGeometry.OpenImmersion
import Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact
import Mathlib.CategoryTheory.MorphismProperty.Composition
import Mathlib.Geometry.RingedSpace.LocallyRingedSpace.ResidueField
import Mathlib.RingTheory.LocalProperties

/-!

# Closed immersions of schemes

A morphism of schemes `f : X ‚ü∂ Y` is a closed immersion if the underlying map of topological spaces
is a closed immersion and the induced morphisms of stalks are all surjective.

## Main definitions

* `IsClosedImmersion` : The property of scheme morphisms stating `f : X ‚ü∂ Y` is a closed immersion.

## TODO

* Show closed immersions of affines are induced by surjective ring maps
* Show closed immersions are stable under pullback
* Show closed immersions are precisely the proper monomorphisms
* Define closed immersions of locally ringed spaces, where we also assume that the kernel of `O_X ‚Üí
  f_*O_Y` is locally generated by sections as an `O_X`-module, and relate it to this file. See
  https://stacks.math.columbia.edu/tag/01HJ.

-/

universe v u

open CategoryTheory

namespace AlgebraicGeometry

/-- A morphism of schemes `X ‚ü∂ Y` is a closed immersion if the underlying
topological map is a closed embedding and the induced stalk maps are surjective. -/
class IsClosedImmersion {X Y : Scheme} (f : X ‚ü∂ Y) : Prop where
  base_closed : ClosedEmbedding f.1.base
  surj_on_stalks : ‚àÄ x, Function.Surjective (PresheafedSpace.stalkMap f.1 x)

namespace IsClosedImmersion

lemma closedEmbedding {X Y : Scheme} (f : X ‚ü∂ Y)
    [IsClosedImmersion f] : ClosedEmbedding f.1.base :=
  IsClosedImmersion.base_closed

lemma surjective_stalkMap {X Y : Scheme} (f : X ‚ü∂ Y)
    [IsClosedImmersion f] (x : X) : Function.Surjective (PresheafedSpace.stalkMap f.1 x) :=
  IsClosedImmersion.surj_on_stalks x

/-- Isomorphisms are closed immersions. -/
instance {X Y : Scheme} (f : X ‚ü∂ Y) [IsIso f] : IsClosedImmersion f where
  base_closed := Homeomorph.closedEmbedding <| TopCat.homeoOfIso (asIso f.1.base)
  surj_on_stalks := fun _ ‚Ü¶ (ConcreteCategory.bijective_of_isIso _).2

instance : MorphismProperty.IsMultiplicative @IsClosedImmersion where
  id_mem _ := inferInstance
  comp_mem {X Y Z} f g hf hg := by
    refine ‚ü®hg.base_closed.comp hf.base_closed, fun x ‚Ü¶ ?_‚ü©
    erw [PresheafedSpace.stalkMap.comp]
    exact (hf.surj_on_stalks x).comp (hg.surj_on_stalks (f.1.1 x))

/-- Composition of closed immersions is a closed immersion. -/
instance comp {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsClosedImmersion f]
    [IsClosedImmersion g] : IsClosedImmersion (f ‚â´ g) :=
  MorphismProperty.IsStableUnderComposition.comp_mem f g inferInstance inferInstance

/-- Composition with an isomorphism preserves closed immersions. -/
instance respectsIso : MorphismProperty.RespectsIso @IsClosedImmersion := by
  constructor <;> intro X Y Z e f hf <;> infer_instance

/-- Given two commutative rings `R S : CommRingCat` and a surjective morphism
`f : R ‚ü∂ S`, the induced scheme morphism `specObj S ‚ü∂ specObj R` is a
closed immersion. -/
theorem spec_of_surjective {R S : CommRingCat} (f : R ‚ü∂ S) (h : Function.Surjective f) :
    IsClosedImmersion (Spec.map f) where
  base_closed := PrimeSpectrum.closedEmbedding_comap_of_surjective _ _ h
  surj_on_stalks x := by
    erw [‚Üê localRingHom_comp_stalkIso, CommRingCat.coe_comp, CommRingCat.coe_comp]
    apply Function.Surjective.comp (Function.Surjective.comp _ _) _
    ¬∑ exact (ConcreteCategory.bijective_of_isIso (StructureSheaf.stalkIso S x).inv).2
    ¬∑ exact surjective_localRingHom_of_surjective f h x.asIdeal
    ¬∑ let g := (StructureSheaf.stalkIso ((CommRingCat.of R))
        ((PrimeSpectrum.comap (CommRingCat.ofHom f)) x)).hom
      exact (ConcreteCategory.bijective_of_isIso g).2

/-- For any ideal `I` in a commutative ring `R`, the quotient map `specObj R ‚ü∂ specObj (R ‚ß∏ I)`
is a closed immersion. -/
instance spec_of_quotient_mk {R : CommRingCat.{u}} (I : Ideal R) :
    IsClosedImmersion (Spec.map (CommRingCat.ofHom (Ideal.Quotient.mk I))) :=
  spec_of_surjective _ Ideal.Quotient.mk_surjective

/-- If `f ‚â´ g` is a closed immersion, then `f` is a closed immersion. -/
theorem of_comp {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsClosedImmersion g]
    [IsClosedImmersion (f ‚â´ g)] : IsClosedImmersion f where
  base_closed := by
    have h := closedEmbedding (f ‚â´ g)
    rw [Scheme.comp_val_base] at h
    apply closedEmbedding_of_continuous_injective_closed (Scheme.Hom.continuous f)
    ¬∑ exact Function.Injective.of_comp h.inj
    ¬∑ intro Z hZ
      rw [ClosedEmbedding.closed_iff_image_closed (closedEmbedding g),
        ‚Üê Set.image_comp]
      exact ClosedEmbedding.isClosedMap h _ hZ
  surj_on_stalks x := by
    have h := surjective_stalkMap (f ‚â´ g) x
    erw [Scheme.comp_val, PresheafedSpace.stalkMap.comp] at h
    exact Function.Surjective.of_comp h

instance {X Y : Scheme} (f : X ‚ü∂ Y) [IsClosedImmersion f] : QuasiCompact f where
  isCompact_preimage _ _ hU' := base_closed.isCompact_preimage hU'

section Affine

open Opposite LocallyRingedSpace

/-- If `f : X ‚ü∂ Y` is a morphism of schemes with quasi-compact source and affine target, `f`
has a closed image and `f` induces an injection on global sections, then
`f` is surjective. -/
lemma surjective_of_isClosed_range_of_injective {X Y : Scheme} [IsAffine Y] [CompactSpace X]
    (f : X ‚ü∂ Y) (hfcl : IsClosed (Set.range f.val.base))
    (hfinj : Function.Injective (f.val.c.app (op ‚ä§))) :
    Function.Surjective f.val.base := by
  obtain ‚ü®I, hI‚ü© := (Scheme.eq_zeroLocus_of_isClosed_of_isAffine Y (Set.range f.val.base)).mp hfcl
  let ùí∞ : X.OpenCover := X.affineCover.finiteSubcover
  haveI (i : ùí∞.J) : IsAffine (ùí∞.obj i) := Scheme.isAffine_affineCover X _
  apply Set.range_iff_surjective.mp
  apply hI ‚ñ∏ (Scheme.zeroLocus_eq_top_iff_subset_nilradical_of_compactSpace _).mpr
  intro s hs
  simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,
    Submodule.mem_toAddSubmonoid, SetLike.mem_coe, mem_nilradical, ‚Üê IsNilpotent.map_iff hfinj]
  refine Scheme.isNilpotent_of_isNilpotent_cover _ ùí∞ (fun i ‚Ü¶ ?_)
  rw [Scheme.isNilpotent_iff_basicOpen_eq_bot_of_compactSpace]
  erw [basicOpen_eq_bot_iff_forall_evaluation_eq_zero]
  intro x
  suffices h : f.val.base ((ùí∞.map i).val.base x.val) ‚àâ Y.toRingedSpace.basicOpen s by
    erw [‚Üê Œìevaluation_naturality_apply (ùí∞.map i ‚â´ f)]
    simpa
  exact (Y.mem_zeroLocus_iff I _).mp (hI ‚ñ∏ Set.mem_range_self ((ùí∞.map i).val.base x.val)) s hs

end Affine

end IsClosedImmersion

end AlgebraicGeometry
