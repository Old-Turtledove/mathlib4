/-
Copyright (c) 2023 Jonas van der Schaaf. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Amelia Livingston, Christian Merten, Jonas van der Schaaf
-/
import Mathlib.AlgebraicGeometry.OpenImmersion
import Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact
import Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated
import Mathlib.CategoryTheory.MorphismProperty.Composition
import Mathlib.Geometry.RingedSpace.LocallyRingedSpace.ResidueField
import Mathlib.RingTheory.LocalProperties

/-!

# Closed immersions of schemes

A morphism of schemes `f : X ‚ü∂ Y` is a closed immersion if the underlying map of topological spaces
is a closed immersion and the induced morphisms of stalks are all surjective.

## Main definitions

* `IsClosedImmersion` : The property of scheme morphisms stating `f : X ‚ü∂ Y` is a closed immersion.

## TODO

* Show closed immersions of affines are induced by surjective ring maps
* Show closed immersions are stable under pullback
* Show closed immersions are precisely the proper monomorphisms
* Define closed immersions of locally ringed spaces, where we also assume that the kernel of `O_X ‚Üí
  f_*O_Y` is locally generated by sections as an `O_X`-module, and relate it to this file. See
  https://stacks.math.columbia.edu/tag/01HJ.

-/

universe v u

open CategoryTheory TopologicalSpace

namespace AlgebraicGeometry

/-- A morphism of schemes `X ‚ü∂ Y` is a closed immersion if the underlying
topological map is a closed embedding and the induced stalk maps are surjective. -/
class IsClosedImmersion {X Y : Scheme} (f : X ‚ü∂ Y) : Prop where
  base_closed : ClosedEmbedding f.1.base
  surj_on_stalks : ‚àÄ x, Function.Surjective (PresheafedSpace.stalkMap f.1 x)

namespace IsClosedImmersion

lemma closedEmbedding {X Y : Scheme} (f : X ‚ü∂ Y)
    [IsClosedImmersion f] : ClosedEmbedding f.1.base :=
  IsClosedImmersion.base_closed

lemma surjective_stalkMap {X Y : Scheme} (f : X ‚ü∂ Y)
    [IsClosedImmersion f] (x : X) : Function.Surjective (PresheafedSpace.stalkMap f.1 x) :=
  IsClosedImmersion.surj_on_stalks x

/-- Isomorphisms are closed immersions. -/
instance {X Y : Scheme} (f : X ‚ü∂ Y) [IsIso f] : IsClosedImmersion f where
  base_closed := Homeomorph.closedEmbedding <| TopCat.homeoOfIso (asIso f.1.base)
  surj_on_stalks := fun _ ‚Ü¶ (ConcreteCategory.bijective_of_isIso _).2

instance : MorphismProperty.IsMultiplicative @IsClosedImmersion where
  id_mem _ := inferInstance
  comp_mem {X Y Z} f g hf hg := by
    refine ‚ü®hg.base_closed.comp hf.base_closed, fun x ‚Ü¶ ?_‚ü©
    erw [PresheafedSpace.stalkMap.comp]
    exact (hf.surj_on_stalks x).comp (hg.surj_on_stalks (f.1.1 x))

/-- Composition of closed immersions is a closed immersion. -/
instance comp {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsClosedImmersion f]
    [IsClosedImmersion g] : IsClosedImmersion (f ‚â´ g) :=
  MorphismProperty.IsStableUnderComposition.comp_mem f g inferInstance inferInstance

/-- Composition with an isomorphism preserves closed immersions. -/
instance respectsIso : MorphismProperty.RespectsIso @IsClosedImmersion := by
  constructor <;> intro X Y Z e f hf <;> infer_instance

/-- Given two commutative rings `R S : CommRingCat` and a surjective morphism
`f : R ‚ü∂ S`, the induced scheme morphism `specObj S ‚ü∂ specObj R` is a
closed immersion. -/
theorem spec_of_surjective {R S : CommRingCat} (f : R ‚ü∂ S) (h : Function.Surjective f) :
    IsClosedImmersion (Spec.map f) where
  base_closed := PrimeSpectrum.closedEmbedding_comap_of_surjective _ _ h
  surj_on_stalks x := by
    erw [‚Üê localRingHom_comp_stalkIso, CommRingCat.coe_comp, CommRingCat.coe_comp]
    apply Function.Surjective.comp (Function.Surjective.comp _ _) _
    ¬∑ exact (ConcreteCategory.bijective_of_isIso (StructureSheaf.stalkIso S x).inv).2
    ¬∑ exact surjective_localRingHom_of_surjective f h x.asIdeal
    ¬∑ let g := (StructureSheaf.stalkIso ((CommRingCat.of R))
        ((PrimeSpectrum.comap (CommRingCat.ofHom f)) x)).hom
      exact (ConcreteCategory.bijective_of_isIso g).2

/-- For any ideal `I` in a commutative ring `R`, the quotient map `specObj R ‚ü∂ specObj (R ‚ß∏ I)`
is a closed immersion. -/
instance spec_of_quotient_mk {R : CommRingCat.{u}} (I : Ideal R) :
    IsClosedImmersion (Spec.map (CommRingCat.ofHom (Ideal.Quotient.mk I))) :=
  spec_of_surjective _ Ideal.Quotient.mk_surjective

/-- If `f ‚â´ g` is a closed immersion, then `f` is a closed immersion. -/
theorem of_comp {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsClosedImmersion g]
    [IsClosedImmersion (f ‚â´ g)] : IsClosedImmersion f where
  base_closed := by
    have h := closedEmbedding (f ‚â´ g)
    rw [Scheme.comp_val_base] at h
    apply closedEmbedding_of_continuous_injective_closed (Scheme.Hom.continuous f)
    ¬∑ exact Function.Injective.of_comp h.inj
    ¬∑ intro Z hZ
      rw [ClosedEmbedding.closed_iff_image_closed (closedEmbedding g),
        ‚Üê Set.image_comp]
      exact ClosedEmbedding.isClosedMap h _ hZ
  surj_on_stalks x := by
    have h := surjective_stalkMap (f ‚â´ g) x
    erw [Scheme.comp_val, PresheafedSpace.stalkMap.comp] at h
    exact Function.Surjective.of_comp h

instance {X Y : Scheme} (f : X ‚ü∂ Y) [IsClosedImmersion f] : QuasiCompact f where
  isCompact_preimage _ _ hU' := base_closed.isCompact_preimage hU'

section Affine

open Opposite LocallyRingedSpace

/-- If `f : X ‚ü∂ Y` is a morphism of schemes with quasi-compact source and affine target, `f`
has a closed image and `f` induces an injection on global sections, then
`f` is surjective. -/
lemma surjective_of_isClosed_range_of_injective {X Y : Scheme} [IsAffine Y] [CompactSpace X]
    {f : X ‚ü∂ Y} (hfcl : IsClosed (Set.range f.val.base))
    (hfinj : Function.Injective (f.app ‚ä§)) :
    Function.Surjective f.val.base := by
  obtain ‚ü®I, hI‚ü© := (Scheme.eq_zeroLocus_of_isClosed_of_isAffine Y (Set.range f.val.base)).mp hfcl
  let ùí∞ : X.OpenCover := X.affineCover.finiteSubcover
  haveI (i : ùí∞.J) : IsAffine (ùí∞.obj i) := Scheme.isAffine_affineCover X _
  apply Set.range_iff_surjective.mp
  apply hI ‚ñ∏ (Scheme.zeroLocus_eq_top_iff_subset_nilradical_of_compactSpace _).mpr
  intro s hs
  simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,
    Submodule.mem_toAddSubmonoid, SetLike.mem_coe, mem_nilradical, ‚Üê IsNilpotent.map_iff hfinj]
  refine Scheme.isNilpotent_of_isNilpotent_cover _ ùí∞ (fun i ‚Ü¶ ?_)
  rw [Scheme.isNilpotent_iff_basicOpen_eq_bot_of_compactSpace]
  erw [basicOpen_eq_bot_iff_forall_evaluation_eq_zero]
  intro x
  suffices h : f.val.base ((ùí∞.map i).val.base x.val) ‚àâ Y.toRingedSpace.basicOpen s by
    erw [‚Üê Œìevaluation_naturality_apply (ùí∞.map i ‚â´ f)]
    simpa
  exact (Y.mem_zeroLocus_iff I _).mp (hI ‚ñ∏ Set.mem_range_self ((ùí∞.map i).val.base x.val)) s hs

lemma injective_of_isLocalization {R S T} [CommRing R] (M : Submonoid R) [CommRing S] [Algebra R S]
    [IsLocalization M S] [CommRing T] (f : S ‚Üí+* T) :
    Function.Injective f ‚Üî ‚àÄ (x y : R),
      algebraMap R S x = algebraMap R S y ‚Üî f (algebraMap R S x) = f (algebraMap R S y) := by
  rw [‚Üê IsLocalization.lift_of_comp (M := M) f, IsLocalization.lift_injective_iff]
  simp

lemma injective_iff_of_isLocalization' {R S T} [CommRing R] (M : Submonoid R) [CommRing S] [Algebra R S]
    [IsLocalization M S] [CommRing T] (f : S ‚Üí+* T) :
    Function.Injective f ‚Üî ‚àÄ (x : R), algebraMap R S x = 0 ‚Üî f (algebraMap R S x) = 0 := by
  rw [injective_of_isLocalization M]
  constructor
  ¬∑ intro h x
    rw [‚Üê map_zero (algebraMap R S), ‚Üê map_zero f, ‚Üê map_zero (algebraMap R S)]
    exact h x 0
  ¬∑ intro h x y
    rw [‚Üê sub_eq_zero]
    nth_rw 2 [‚Üê sub_eq_zero]
    repeat rw [‚Üê map_sub]
    exact h (x - y)

lemma injective_of_isLocalization' {R S T} [CommRing R] (M : Submonoid R) [CommRing S] [Algebra R S]
    [IsLocalization M S] [CommRing T] (f : S ‚Üí+* T)
    (h : ‚àÄ (x : R), f (algebraMap R S x) = 0 ‚Üí algebraMap R S x = 0) :
    Function.Injective f := by
  rw [injective_iff_of_isLocalization' M]
  exact fun x ‚Ü¶ ‚ü®fun h ‚Ü¶ by rw [h]; simp, h x‚ü©

theorem _root_.AlgebraicGeometry.IsAffineOpen.stalkMap_injective_of {X Y : Scheme} (f : X ‚ü∂ Y) {U : Opens Y}
    (hU : IsAffineOpen U) (x : X) (hx : f.val.base x ‚àà U)
    (h : ‚àÄ g, LocallyRingedSpace.stalkMap f x (Y.presheaf.germ ‚ü®f.val.base x, hx‚ü© g) = 0 ‚Üí
      Y.presheaf.germ ‚ü®f.val.base x, hx‚ü© g = 0) :
    Function.Injective (LocallyRingedSpace.stalkMap f x) := by
  have := hU.isLocalization_stalk ‚ü®f.val.base x, hx‚ü©
  apply @injective_of_isLocalization' _ _ _ _ (hU.primeIdealOf ‚ü®f.val.base x, hx‚ü©).asIdeal.primeCompl
    _ (Y.presheaf.algebra_section_stalk ‚ü®f.val.base x, hx‚ü©)
  exact h

theorem stalkMap_injective_of {X Y : Scheme} (f : X ‚ü∂ Y) [IsAffine Y] (x : X)
    (h : ‚àÄ g,
      LocallyRingedSpace.stalkMap f x (Y.ŒìToStalk (f.val.base x) g) = 0 ‚Üí Y.ŒìToStalk (f.val.base x) g = 0) :
    Function.Injective (LocallyRingedSpace.stalkMap f x) :=
  (isAffineOpen_top Y).stalkMap_injective_of f x trivial h

lemma ŒìToStalk_eq_zero_of {X : Scheme} (x : X) (f s : Œì(X, ‚ä§)) (hx : x ‚àà X.basicOpen s)
    {n : ‚Ñï} (hf : s ^ n * f = 0) : X.ŒìToStalk x f = 0 := by
  rw [Scheme.mem_basicOpen_top] at hx
  replace hx : IsUnit (X.ŒìToStalk x s) := hx
  have hu : IsUnit (X.ŒìToStalk x (s ^ n)) := by
    rw [map_pow]
    exact IsUnit.pow n hx
  rw [‚Üê hu.mul_right_eq_zero, ‚Üê map_mul, hf, map_zero]

lemma pow_mul_eq_zero_of_le {R : Type*} [CommRing R] {a b : R} {m n : ‚Ñï} (hmn : m ‚â§ n)
    (h : a ^ m * b = 0) : a ^ n * b = 0 := by
  have : n = n - m + m := by
    omega
  rw [show n = n - m + m by omega, pow_add, mul_assoc, h]
  simp

lemma map_le {X Y : Scheme} (f : X ‚ü∂ Y) {U V : Opens Y} (hUV : U ‚â§ V) :
    f‚Åª¬π·µÅ U ‚â§ f‚Åª¬π·µÅ V :=
  leOfHom <| (Opens.map f.val.base).map (homOfLE hUV)

/-- If `f : X ‚ü∂ Y` is open, injective, `X` is quasi-compact and `Y` is affine, then `f` is stalkwise
injective if it is injective on global sections. -/
lemma stalkMap_injective_of_isOpenMap_of_injective {X Y : Scheme} {f : X ‚ü∂ Y} [CompactSpace X]
    [IsAffine Y] (hfopen : IsOpenMap f.val.base) (hfinj‚ÇÅ : Function.Injective f.val.base)
    (hfinj‚ÇÇ : Function.Injective (f.app ‚ä§)) (x : X) :
    Function.Injective (LocallyRingedSpace.stalkMap f x) := by
  let œÜ : Œì(Y, ‚ä§) ‚ü∂ Œì(X, ‚ä§) := f.app ‚ä§
  let ùí∞ : X.OpenCover := X.affineCover.finiteSubcover
  have (i : ùí∞.J) : IsAffine (ùí∞.obj i) := Scheme.isAffine_affineCover X _
  let res (i : ùí∞.J) : Œì(X, ‚ä§) ‚ü∂ Œì(ùí∞.obj i, ‚ä§) := (ùí∞.map i).app ‚ä§
  refine stalkMap_injective_of _ _ (fun (g : Œì(Y, ‚ä§)) h ‚Ü¶ ?_)
  erw [ŒìToStalk_stalkMap_apply] at h
  obtain ‚ü®U, w, (hx : x ‚àà U), hg‚ü© :=
    X.toRingedSpace.eq_zero_res_of_eq_zero_germ ‚ä§ (œÜ g) ‚ü®x, trivial‚ü© h
  obtain ‚ü®_, ‚ü®s, rfl‚ü©, hyv, bsle‚ü© := Opens.isBasis_iff_nbhd.mp (isBasis_basicOpen Y)
    (show f.val.base x ‚àà ‚ü®f.val.base '' U.carrier, hfopen U.carrier U.is_open'‚ü© from ‚ü®x, by simpa‚ü©)
  let W (i : ùí∞.J) : TopologicalSpace.Opens (ùí∞.obj i) := (ùí∞.obj i).basicOpen ((res i) (œÜ s))
  have hwle (i : ùí∞.J) : W i ‚â§ (ùí∞.map i)‚Åª¬π·µÅ U := by
    show ((ùí∞.obj i).basicOpen ((ùí∞.map i ‚â´ f).app ‚ä§ s)) ‚â§ _
    rw [‚Üê Scheme.preimage_basicOpen, Scheme.comp_coeBase, Opens.map_comp_obj]
    refine map_le _ (le_trans (map_le f bsle) (le_of_eq ?_))
    simp [Set.preimage_image_eq _ hfinj‚ÇÅ]
  have h0 (i : ùí∞.J) : (ùí∞.map i).appLE _ (W i) (by simp) (œÜ g) = 0 := by
    rw [‚Üê Scheme.Hom.appLE_map _ _ (homOfLE <| hwle i).op, ‚Üê Scheme.Hom.map_appLE _ le_rfl w.op]
    simp only [CommRingCat.coe_comp_of, RingHom.coe_comp, Function.comp_apply]
    erw [hg]
    simp only [map_zero]
  have h1 (i : ùí∞.J) : ‚àÉ n, (res i) (œÜ (s ^ n * g)) = 0 := by
    obtain ‚ü®n, hn‚ü© := exists_of_Œìres_zero_of_qcqs (s := ((res i) (œÜ s))) (h0 i)
    exact ‚ü®n, by rwa [map_mul, map_mul, map_pow, map_pow]‚ü©
  have h2 : ‚àÉ n, ‚àÄ i, (res i) (œÜ (s ^ n * g)) = 0 := by
    choose fn hfn using h1
    refine ‚ü®Finset.sup Finset.univ fn, fun i ‚Ü¶ ?_‚ü©
    rw [map_mul, map_pow, map_mul, map_pow]
    simp only [map_mul, map_pow, map_mul, map_pow] at hfn
    apply pow_mul_eq_zero_of_le (Finset.le_sup (Finset.mem_univ i)) (hfn i)
  obtain ‚ü®n, hn‚ü© := h2
  apply ŒìToStalk_eq_zero_of (f.val.base x) g s hyv
  rw [RingHom.injective_iff_ker_eq_bot, RingHom.ker_eq_bot_iff_eq_zero] at hfinj‚ÇÇ
  exact hfinj‚ÇÇ _ (Scheme.zero_of_zero_cover _ _ hn)

/-- If `f` is a closed immersion with affine target such that the induced map on global
sections is injective, `f` is an isomorphism. -/
theorem isIso_of_isClosedImmersion_of_injective_of_isAffine {X Y : Scheme} [IsAffine Y]
    (f : X ‚ü∂ Y) [IsClosedImmersion f] (hf : Function.Injective (f.app ‚ä§)) :
    IsIso f := (isIso_iff_stalk_iso f).mpr <|
  have : CompactSpace X := (closedEmbedding f).compactSpace
  have hiso : IsIso f.val.base := TopCat.isIso_of_bijective_of_isClosedMap _
    ‚ü®(closedEmbedding f).inj,
     surjective_of_isClosed_range_of_injective ((closedEmbedding f).isClosed_range) hf‚ü©
    ((closedEmbedding f).isClosedMap)
  ‚ü®hiso, fun x ‚Ü¶ (ConcreteCategory.isIso_iff_bijective _).mpr
    ‚ü®stalkMap_injective_of_isOpenMap_of_injective ((TopCat.homeoOfIso (asIso f.val.base)).isOpenMap)
    (closedEmbedding f).inj hf _, surjective_stalkMap f x‚ü©‚ü©

end Affine

end IsClosedImmersion

end AlgebraicGeometry
