/-
Copyright (c) 2024 Weihong Xu. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kevin Buzzard, Johan Commelin, Amelia Livingston, Sophie Morel, Jujian Zhang, Weihong Xu
-/

import Mathlib.Algebra.Module.LocalizedModule
import Mathlib.AlgebraicGeometry.StructureSheaf
import Mathlib.Algebra.Category.ModuleCat.Sheaf
import Mathlib.Algebra.Category.ModuleCat.FilteredColimits

/-!

# Construction of M^~

Given any commutative ring `R` and `R`-module `M`, we construct the sheaf `M^~` of `ùí™_SpecR`-modules
such that `M^~(U)` is the set of dependent functions that are locally fractions.

## Main definitions

* `AlgebraicGeometry.TildeInAddCommGrp` : `M^~` as a sheaf of abelian groups.
* `AlgebraicGeometry.TildeInModules` : `M^~` as a sheaf of `ùí™_{Spec R}`-modules.

-/

universe u

open TopCat AlgebraicGeometry TopologicalSpace CategoryTheory Opposite

variable (R : Type u) [CommRing R] (M : Type u) [AddCommGroup M] [Module R M]

namespace AlgebraicGeometry

namespace Tilde

/-- For an `R`-module `M` and a point `P` in `Spec R`, `Localizations P` is the localized module
`M` at the prime ideal `P`. -/
abbrev Localizations (P : PrimeSpectrum.Top R) :=
LocalizedModule P.asIdeal.primeCompl M

/-- For any open subset `U ‚äÜ Spec R`, `IsFraction` is the predicate expressing that a function
`f : ‚àè_{x ‚àà U}, M‚Çì` is such that for any `ùî≠ ‚àà U`, `f ùî≠ = m / s` for some `m : M` and `s ‚àâ ùî≠`.
In short `f` is a fraction on `U`. -/
def IsFraction {U : Opens (PrimeSpectrum R)} (f : ‚àÄ ùî≠ : U, Localizations R M ùî≠.1) : Prop :=
  ‚àÉ (m : M) (s : R),
    ‚àÄ x : U, ¬¨s ‚àà x.1.asIdeal ‚àß s ‚Ä¢ f x = LocalizedModule.mkLinearMap x.1.asIdeal.primeCompl M m

/--
The property of a function `f : ‚àè_{x ‚àà U}, M‚Çì` being a fraction is stable under restriction.
-/
def isFractionPrelocal : PrelocalPredicate (Localizations R M) where
  pred {U} f := IsFraction R M f
  res := by rintro V U i f ‚ü®m, s, w‚ü©; exact ‚ü®m, s, fun x => w (i x)‚ü©

/--
For any open subset `U ‚äÜ Spec R`, `IsLocallyFraction` is the predicate expressing that a function
`f : ‚àè_{x ‚àà U}, M‚Çì` is such that for any `ùî≠ ‚àà U`, there exists an open neighbourhood `V ‚àã ùî≠`, such
that for any `ùîÆ ‚àà V`, `f ùîÆ = m / s` for some `m : M` and `s ‚àâ ùîÆ`.
In short `f` is locally a fraction on `U`.
-/
def isLocallyFraction : LocalPredicate (Localizations R M) := (isFractionPrelocal R M).sheafify

end Tilde

/--
For any `R`-module `M`, `TildeInType R M` is the sheaf of set on `Spec R` whose sections on `U` are
the dependent functions that are locally fractions. This is often denoted by `M^~`.

See also `Tilde.isLocallyFraction`.
-/
def TildeInType : Sheaf (Type u) (PrimeSpectrum.Top R) :=
  subsheafToTypes (Tilde.isLocallyFraction R M)

namespace Tilde

@[simp]
theorem isLocallyFraction_pred {U : Opens (PrimeSpectrum.Top R)}
    (f : ‚àÄ x : U, Localizations R M x) :
    (isLocallyFraction R M).pred f =
      ‚àÄ y : U,
        ‚àÉ (V : _) (_ : y.1 ‚àà V) (i : V ‚ü∂ U),
          ‚àÉ (m: M) (s: R), ‚àÄ x : V, ¬¨s ‚àà x.1.asIdeal ‚àß s‚Ä¢ f (i x) =
            LocalizedModule.mkLinearMap x.1.asIdeal.primeCompl M m :=
  rfl

/- M_x is an O_SpecR(U)-module when x is in U -/
noncomputable instance (U : (Opens (PrimeSpectrum.Top R))·µí·µñ) (x : U.unop):
    Module ((Spec.structureSheaf R).val.obj U) (Localizations R M ‚Üëx):=
  Module.compHom (R := (Localization.AtPrime x.1.asIdeal)) _
    (StructureSheaf.openToLocalization R U.unop x x.2 :
      (Spec.structureSheaf R).val.obj U ‚Üí+* Localization.AtPrime x.1.asIdeal)

lemma sections_smul_localizations_def (U : (Opens (PrimeSpectrum.Top R))·µí·µñ) (x : U.unop)
    (r : (Spec.structureSheaf R).val.obj U)
    (m : Localizations R M ‚Üëx) :
  r ‚Ä¢ m = r.1 x ‚Ä¢ m := rfl

/--
For any `R`-module `M` and any open subset `U ‚äÜ Spec R`, `M^~(U)` is an `ùí™_{Spec R}(U)`-submodule
of `‚àè_{ùî≠ ‚àà U} M_ùî≠`. -/
def sectionsSubmodule (U : (Opens (PrimeSpectrum R))·µí·µñ) :
    Submodule ((Spec.structureSheaf R).1.obj U) (‚àÄ x : U.unop, Localizations R M x.1) where
  carrier := { f | (isLocallyFraction R M).pred f }
  zero_mem' := by
    refine fun x => ‚ü®unop U, x.2, ùüô _, 0, 1, fun y => ‚ü®?_, ?_‚ü©‚ü©
    ¬∑ rw [‚Üê Ideal.ne_top_iff_one]; exact y.1.isPrime.1
    ¬∑ simp
  add_mem' := by
    intro a b ha hb x
    rcases ha x with ‚ü®Va, ma, ia, ra, sa, wa‚ü©
    rcases hb x with ‚ü®Vb, mb, ib, rb, sb, wb‚ü©
    refine ‚ü®Va ‚äì Vb, ‚ü®ma, mb‚ü©, Opens.infLELeft _ _ ‚â´ ia,  sb‚Ä¢ ra+ sa‚Ä¢rb , sa * sb, ?_‚ü©
    intro y
    rcases wa (Opens.infLELeft _ _ y : Va) with ‚ü®nma, wa‚ü©
    rcases wb (Opens.infLERight _ _ y : Vb) with ‚ü®nmb, wb‚ü©
    fconstructor
    ¬∑ intro H; cases y.1.isPrime.mem_or_mem H <;> contradiction
    ¬∑ simp only [Opens.coe_inf, Pi.add_apply, smul_add, map_add, LinearMapClass.map_smul]
      dsimp at wa wb ‚ä¢
      rw [‚Üê wa, ‚Üê wb, ‚Üê mul_smul, ‚Üê mul_smul]
      congr 2
      simp [mul_comm]
  smul_mem' := by
    intro r a ha x
    rcases ha x with ‚ü®Va, ma, ia, ra, sa, wa‚ü©
    rcases r.2 x with ‚ü®Vr, mr, ir, rr, sr, wr‚ü©
    refine ‚ü®Va ‚äì Vr, ‚ü®ma, mr‚ü©, Opens.infLELeft _ _ ‚â´ ia, rr‚Ä¢ra, sr*sa, ?_‚ü©
    intro y
    rcases wa (Opens.infLELeft _ _ y : Va) with ‚ü®nma, wa‚ü©
    rcases wr (Opens.infLERight _ _ y) with ‚ü®nmr, wr‚ü©
    fconstructor
    ¬∑ intro H; cases y.1.isPrime.mem_or_mem H <;> contradiction
    ¬∑ simp only [Opens.coe_inf, Pi.smul_apply, LinearMapClass.map_smul]
      dsimp at wa wr ‚ä¢
      rw [mul_comm, ‚Üê Algebra.smul_def] at wr
      rw [sections_smul_localizations_def, ‚Üê wa, ‚Üê mul_smul, ‚Üê smul_assoc, mul_comm sr,
        mul_smul, wr, mul_comm rr, Algebra.smul_def, ‚Üê map_mul]
      rfl

instance (U : (Opens (PrimeSpectrum.Top R))·µí·µñ) :
    AddCommGroup ((TildeInType R M).1.obj U) :=
  inferInstanceAs $ AddCommGroup (sectionsSubmodule R M U)

/--
`M^~` as a presheaf of abelian groups over `Spec R`
-/
def presheafInAddCommGrp : Presheaf AddCommGrp (PrimeSpectrum.Top R) where
  obj U := AddCommGrp.of ((TildeInType R M).1.obj U)
  map {U V} i :=
    { toFun := (TildeInType R M).1.map i
      map_zero' := rfl
      map_add' := fun x y => rfl}

/--
Implementation details:
checking that after forgeting the abelian group structure of `M^~` as sheaf of abelian groups, we
get the original sheaf of sets.
-/
def presheafCompForget :
    presheafInAddCommGrp R M ‚ãô forget AddCommGrp ‚âÖ (TildeInType R M).1 :=
  NatIso.ofComponents fun U => Iso.refl _

end Tilde

/--
`M^~` as a sheaf of abelian groups over `Spec R`
-/
def TildeInAddCommGrp : Sheaf AddCommGrp (PrimeSpectrum.Top R) :=
  ‚ü®Tilde.presheafInAddCommGrp R M,
    (TopCat.Presheaf.isSheaf_iff_isSheaf_comp _ _).mpr
      (TopCat.Presheaf.isSheaf_of_iso (Tilde.presheafCompForget R M).symm (TildeInType R M).cond)‚ü©

-- `SheafOfModules` want `Sheaf ... RingCat`; but we have a `Sheaf ... CommRingCat`, so we forget.
local notation3 "ùí™_SpecR" =>
  sheafCompose (Opens.grothendieckTopology (PrimeSpectrum.Top R))
    (forget‚ÇÇ CommRingCat RingCat) |>.obj (Spec.structureSheaf R)

noncomputable instance (U : (Opens (PrimeSpectrum.Top R))·µí·µñ) :
    Module ((ùí™_SpecR).val.obj U) ((Tilde.presheafInAddCommGrp R M).obj U) :=
  inferInstanceAs $ Module _ (Tilde.sectionsSubmodule R M U)

noncomputable instance (U : (Opens (PrimeSpectrum.Top R))·µí·µñ) :
    Module ((Spec.structureSheaf R).1.obj U) ((Tilde.presheafInAddCommGrp R M).obj U) :=
  inferInstanceAs $ Module _ (Tilde.sectionsSubmodule R M U)

open Tilde in
/--
`M^~` as a sheaf of `ùí™_{Spec R}`-modules
-/
noncomputable def TildeAsSheafOfModules : SheafOfModules (ùí™_SpecR) where
  val := {
    presheaf := (presheafInAddCommGrp R M)
    module := inferInstance
    map_smul := by
      intro U V f r m
      dsimp [TildeInAddCommGrp, presheafInAddCommGrp, TildeInType]
      ext x
      change (Spec.structureSheaf R).val.obj U at r
      change r ‚Ä¢ (m.1 ‚ü®x.1, _‚ü©) = _
      rw [sections_smul_localizations_def]
      rfl
  }
  isSheaf := (TildeInAddCommGrp R M).2

noncomputable def TildeInModuleCat :
    TopCat.Presheaf (ModuleCat R) (PrimeSpectrum.Top R) :=
  (PresheafOfModules.forgetToPresheafModuleCat (op ‚ä§) $
    Limits.initialOpOfTerminal Limits.isTerminalTop).obj (TildeAsSheafOfModules R M).1 ‚ãô
  ModuleCat.restrictScalars (StructureSheaf.globalSectionsIso R).hom

namespace Tilde

@[simp]
theorem res_apply (U V : Opens (PrimeSpectrum.Top R)) (i : V ‚ü∂ U)
    (s : (TildeInModuleCat R M).obj (op U)) (x : V) :
    ((TildeInModuleCat R M).map i.op s).1 x = (s.1 (i x) : _) :=
  rfl

lemma smul_section_apply (r : R) (U : Opens (PrimeSpectrum.Top R))
    (s : (TildeInModuleCat R M).1.obj (op U)) (x : U) :
    (r ‚Ä¢ s).1 x = r ‚Ä¢ (s.1 x) := rfl

lemma smul_germ (r : R) (U : Opens (PrimeSpectrum.Top R)) (x : U)
    (s : (TildeInModuleCat R M).1.obj (op U)) :
    r ‚Ä¢ (TildeInModuleCat R M).germ x s =
    (TildeInModuleCat R M).germ x (r ‚Ä¢ s) := by rw [map_smul]

/-- The ring homomorphism that takes a section of the structure sheaf of `R` on the open set `U`,
implemented as a subtype of dependent functions to localizations at prime ideals, and evaluates
the section on the point corresponding to a given prime ideal. -/
def openToLocalization (U : Opens (PrimeSpectrum.Top R)) (x : PrimeSpectrum.Top R) (hx : x ‚àà U) :
    (TildeInModuleCat R M).1.obj (op U) ‚ü∂
    ModuleCat.of R (LocalizedModule x.asIdeal.primeCompl M) where
  toFun s := (s.1 ‚ü®x, hx‚ü© : _)
  map_add' _ _ := rfl
  map_smul' _ _ := rfl

@[simp]
theorem coe_openToLocalization (U : Opens (PrimeSpectrum.Top R)) (x : PrimeSpectrum.Top R)
    (hx : x ‚àà U) :
    (openToLocalization R M U x hx :
        (TildeInAddCommGrp R M).1.obj (op U) ‚Üí LocalizedModule x.asIdeal.primeCompl M) =
      fun s => (s.1 ‚ü®x, hx‚ü© : _) :=
  rfl

theorem openToLocalization_apply (U : Opens (PrimeSpectrum.Top R)) (x : PrimeSpectrum.Top R)
    (hx : x ‚àà U) (s : (TildeInAddCommGrp R M).1.obj (op U)) :
    openToLocalization R M U x hx s = (s.1 ‚ü®x, hx‚ü© : _) :=
  rfl

noncomputable def stalkToFiberLinearMap (x : PrimeSpectrum.Top R) :
    TopCat.Presheaf.stalk (TildeInModuleCat R M) x ‚ü∂
    ModuleCat.of R (LocalizedModule x.asIdeal.primeCompl M) :=
  Limits.colimit.desc ((OpenNhds.inclusion x).op ‚ãô (TildeInModuleCat R M))
    { pt := _
      Œπ :=
      { app := fun U =>
          (openToLocalization R M ((OpenNhds.inclusion _).obj (unop U)) x (unop U).2)
        naturality := fun {U V} i => by aesop_cat } }

@[simp]
theorem germ_comp_stalkToFiberLinearMap (U : Opens (PrimeSpectrum.Top R)) (x : U) :
    TopCat.Presheaf.germ (TildeInModuleCat R M) x ‚â´ stalkToFiberLinearMap R M x =
    openToLocalization R M U x x.2 :=
  Limits.colimit.Œπ_desc _ _

@[simp]
theorem stalkToFiberLinearMap_germ' (U : Opens (PrimeSpectrum.Top R)) (x : PrimeSpectrum.Top R)
    (hx : x ‚àà U) (s : (TildeInModuleCat R M).1.obj (op U)) :
    stalkToFiberLinearMap R M x
      (TopCat.Presheaf.germ (TildeInModuleCat R M) ‚ü®x, hx‚ü© s) = (s.1 ‚ü®x, hx‚ü© : _) :=
  DFunLike.ext_iff.1 (germ_comp_stalkToFiberLinearMap R M U ‚ü®x, hx‚ü© : _) s

@[simp]
theorem stalkToFiberLinearMap_germ (U : Opens (PrimeSpectrum.Top R)) (x : U)
    (s : (TildeInModuleCat R M).1.obj (op U)) :
    stalkToFiberLinearMap R M x (TopCat.Presheaf.germ (TildeInModuleCat R M) x s) =
    s.1 x := by
  cases x; exact stalkToFiberLinearMap_germ' R M U _ _ _

def toOpen (U : Opens (PrimeSpectrum.Top R)) :
    ModuleCat.of R M ‚ü∂ (TildeInModuleCat R M).1.obj (op U) where
  toFun f :=
  ‚ü®fun x => LocalizedModule.mkLinearMap _ _ f, fun x =>
    ‚ü®U, x.2, ùüô _, f, 1, fun y => ‚ü®(Ideal.ne_top_iff_one _).1 y.1.2.1, by simp‚ü©‚ü©‚ü©
  map_add' f g := Subtype.eq <| funext fun x => LinearMap.map_add _ _ _
  map_smul' r m := by
    simp only [isLocallyFraction_pred, LocalizedModule.mkLinearMap_apply, LinearMapClass.map_smul,
      RingHom.id_apply]
    rfl

@[simp]
theorem toOpen_res (U V : Opens (PrimeSpectrum.Top R)) (i : V ‚ü∂ U) :
    toOpen R M U ‚â´ (TildeInModuleCat R M).map i.op = toOpen R M V :=
  rfl

noncomputable def toStalk (x : PrimeSpectrum.Top R) :
    ModuleCat.of R M ‚ü∂ TopCat.Presheaf.stalk (TildeInModuleCat R M) x :=
  (toOpen R M ‚ä§ ‚â´ TopCat.Presheaf.germ (TildeInModuleCat R M) ‚ü®x, by trivial‚ü©)

@[simp]
theorem toOpen_germ (U : Opens (PrimeSpectrum.Top R)) (x : U) :
    toOpen R M U ‚â´ TopCat.Presheaf.germ (TildeInModuleCat R M) x = toStalk R M x := by
  rw [‚Üê toOpen_res R M ‚ä§ U (homOfLE le_top : U ‚ü∂ ‚ä§), Category.assoc, Presheaf.germ_res]; rfl

@[simp]
theorem germ_toOpen (U : Opens (PrimeSpectrum.Top R)) (x : U) (f : M) :
    TopCat.Presheaf.germ (TildeInModuleCat R M) x
      (toOpen R M U f) = toStalk R M x f := by rw [‚Üê toOpen_germ]; rfl

lemma isUnit_toStalk (x : PrimeSpectrum.Top R) (r : x.asIdeal.primeCompl) :
    IsUnit ((algebraMap R (Module.End R ((TildeInModuleCat R M).stalk x))) r) := by
  rw [Module.End_isUnit_iff]
  refine ‚ü®?_, ?_‚ü©
  ¬∑ rw [‚Üê LinearMap.ker_eq_bot, eq_bot_iff]
    intro st h
    simp only [LinearMap.mem_ker, Module.algebraMap_end_apply] at h
    change st = 0
    obtain ‚ü®U, mem, s, rfl‚ü© := TopCat.Presheaf.germ_exist (F := (TildeInModuleCat R M)) x st
    erw [smul_germ] at h
    rw [show (0 : (TildeInModuleCat R M).stalk x) = (TildeInModuleCat R M).germ ‚ü®x, mem‚ü© 0 by
      rw [map_zero]] at h

    obtain ‚ü®W, mem_W, iU, iV, h‚ü© := TopCat.Presheaf.germ_eq (h := h)
    rw [map_smul, map_zero] at h
    obtain ‚ü®W', (mem_W' : x ‚àà W'), (iW : W' ‚ü∂ W), num, den, eq1‚ü© :=
      ((TildeInModuleCat R M).map iU.op) s |>.2 ‚ü®x, mem_W‚ü©
    let O := W' ‚äì (PrimeSpectrum.basicOpen r)
    suffices (TildeInModuleCat R M).map
        (op $ (homOfLE $ inf_le_left.trans (leOfHom $ iW ‚â´ iU) : O ‚ü∂ U)) s = 0 by
      apply_fun (TildeInModuleCat R M).germ
        (‚ü®x, ‚ü®mem_W', r.2‚ü©‚ü© : (W' ‚äì PrimeSpectrum.basicOpen r.1 : Opens _)) at this
      erw [TopCat.Presheaf.germ_res_apply] at this
      rw [this, map_zero]

    refine Subtype.ext $ funext fun q => show _ = 0 from ?_
    obtain ‚ü®_, eq1‚ü© := eq1 ‚ü®q.1, q.2.1‚ü©
    simp only [isLocallyFraction_pred, LocalizedModule.mkLinearMap_apply, res_apply] at eq1
    change s.1 ‚ü®q, _‚ü© = 0
    apply_fun (TildeInModuleCat R M).map (op iW) at h
    rw [map_smul] at h
    replace h := congr_fun (Subtype.ext_iff.1 h) ‚ü®q.1, q.2.1‚ü©
    change r.1 ‚Ä¢ s.1 ‚ü®q.1, _‚ü© = 0 at h
    set x := s.1 ‚ü®q.1, _‚ü©
    clear_value x
    induction x using LocalizedModule.induction_on with
    | h a b =>
      rw [LocalizedModule.smul'_mk, show (0 : Localizations R M q) = LocalizedModule.mk 0 1 by rfl,
        LocalizedModule.mk_eq] at h
      obtain ‚ü®(c : q.1.asIdeal.primeCompl), hc‚ü© := h
      simp only [Quiver.Hom.unop_op', one_smul, smul_zero] at hc
      rw [show (0 : Localizations R M q) = LocalizedModule.mk 0 1 by rfl, LocalizedModule.mk_eq]
      refine ‚ü®c * ‚ü®r, q.2.2‚ü©, ?_‚ü©
      simp only [Quiver.Hom.unop_op', one_smul, smul_zero, mul_smul]
      exact hc

  ¬∑ intro st
    obtain ‚ü®U, mem, s, rfl‚ü© := TopCat.Presheaf.germ_exist (F := (TildeInModuleCat R M)) x st
    let O := U ‚äì (PrimeSpectrum.basicOpen r)
    have mem_O : x ‚àà O := ‚ü®mem, r.2‚ü©
    refine ‚ü®TopCat.Presheaf.germ (TildeInModuleCat R M) ‚ü®x, mem_O‚ü©
      ‚ü®fun q => (Localization.mk 1 ‚ü®r, q.2.2‚ü© : Localization.AtPrime q.1.asIdeal) ‚Ä¢ s.1
        ‚ü®q.1, q.2.1‚ü©, fun q => ?_‚ü©, ?_‚ü©
    ¬∑ obtain ‚ü®V, mem_V, (iV : V ‚ü∂ U), num, den, hV‚ü© := s.2 ‚ü®q.1, q.2.1‚ü©
      refine ‚ü®V ‚äì O, ‚ü®mem_V, q.2‚ü©, homOfLE inf_le_right, num, r * den, fun y => ?_‚ü©
      obtain ‚ü®h1, h2‚ü© := hV ‚ü®y, y.2.1‚ü©
      refine ‚ü®y.1.asIdeal.primeCompl.mul_mem y.2.2.2 h1, ?_‚ü©
      simp only [Opens.coe_inf, isLocallyFraction_pred, LocalizedModule.mkLinearMap_apply] at h2 ‚ä¢
      set x := s.1 ‚ü®y.1, _‚ü©
      clear_value x
      induction x using LocalizedModule.induction_on with
      | h a b =>
      rw [LocalizedModule.mk_smul_mk, one_smul, LocalizedModule.smul'_mk, ‚Üê h2,
        LocalizedModule.smul'_mk, LocalizedModule.mk_eq]
      refine ‚ü®1, ?_‚ü©
      simp only [one_smul]
      rw [mul_comm _ b, mul_smul, mul_smul]
      rfl
    ¬∑ simp only [isLocallyFraction_pred, LocalizedModule.mkLinearMap_apply,
        Module.algebraMap_end_apply]
      rw [‚Üê map_smul]
      fapply TopCat.Presheaf.germ_ext
      ¬∑ exact O
      ¬∑ exact mem_O
      ¬∑ exact ùüô _
      ¬∑ exact homOfLE inf_le_left
      refine Subtype.eq <| funext fun y => ?_
      simp only [isLocallyFraction_pred, LocalizedModule.mkLinearMap_apply, op_id,
        CategoryTheory.Functor.map_id, LinearMapClass.map_smul,
        id_apply]
      rw [smul_section_apply]
      change _ = s.1 ‚ü®y.1, _‚ü©
      set x := s.1 ‚ü®y.1, _‚ü©
      change r.1 ‚Ä¢ Localization.mk 1 _ ‚Ä¢ x = _
      clear_value x

      induction x using LocalizedModule.induction_on with
      | h a b =>
        rw [LocalizedModule.mk_smul_mk, one_smul, LocalizedModule.smul'_mk, LocalizedModule.mk_eq]
        refine ‚ü®1, ?_‚ü©
        simp only [one_smul]
        rw [mul_comm _ b, mul_smul]
        rfl

noncomputable def localizationToStalk (x : PrimeSpectrum.Top R) :
    ModuleCat.of R (LocalizedModule x.asIdeal.primeCompl M) ‚ü∂
    (TopCat.Presheaf.stalk (TildeInModuleCat R M) x) :=
  LocalizedModule.lift _ (toStalk R M x) $ isUnit_toStalk R M x

@[simp]
theorem toStalk_comp_stalkToFiberLinearMap (x : PrimeSpectrum.Top R) :
    -- Porting note: now `algebraMap _ _` needs to be explicitly typed
    toStalk R M x ‚â´ stalkToFiberLinearMap R M x =
    LocalizedModule.mkLinearMap x.asIdeal.primeCompl M := by
  erw [toStalk, Category.assoc, germ_comp_stalkToFiberLinearMap]; rfl

@[simp]
theorem stalkToFiberRingHom_toStalk (x : PrimeSpectrum.Top R) (m : M) :
    stalkToFiberLinearMap R M x (toStalk R M x m) =
    LocalizedModule.mk m 1 :=
  LinearMap.ext_iff.1 (toStalk_comp_stalkToFiberLinearMap R M x) _

def const (m : M) (r : R) (U : Opens (PrimeSpectrum.Top R))
    (hu : ‚àÄ x ‚àà U, r ‚àà (x : PrimeSpectrum.Top R).asIdeal.primeCompl) :
    (TildeInModuleCat R M).obj (op U) :=
  ‚ü®fun x => LocalizedModule.mk m ‚ü®r, hu x x.2‚ü©, fun x =>
    ‚ü®U, x.2, ùüô _, m, r, fun y => ‚ü®hu _ y.2, by
      simp only [LocalizedModule.mkLinearMap_apply, LocalizedModule.smul'_mk]
      rw [LocalizedModule.mk_eq]
      exact ‚ü®1, by simp‚ü©‚ü©‚ü©‚ü©

@[simp]
theorem const_apply (m : M) (r : R) (U : Opens (PrimeSpectrum.Top R))
    (hu : ‚àÄ x ‚àà U, r ‚àà (x : PrimeSpectrum.Top R).asIdeal.primeCompl) (x : U) :
    (const R M m r U hu).1 x = LocalizedModule.mk m ‚ü®r, hu x x.2‚ü© :=
  rfl

theorem const_apply' (m : M) (r : R) (U : Opens (PrimeSpectrum.Top R))
    (hu : ‚àÄ x ‚àà U, r ‚àà (x : PrimeSpectrum.Top R).asIdeal.primeCompl) (x : U)
    (hx : r ‚àà (x : PrimeSpectrum.Top R).asIdeal.primeCompl) :
    (const R M m r U hu).1 x = LocalizedModule.mk m ‚ü®r, hx‚ü© :=
  rfl

theorem exists_const (U) (s : (TildeInModuleCat R M).obj (op U)) (x : PrimeSpectrum.Top R)
    (hx : x ‚àà U) :
    ‚àÉ (V : Opens (PrimeSpectrum.Top R)) (_ : x ‚àà V) (i : V ‚ü∂ U) (f : M) (g : R) (hg : _),
      const R M f g V hg = (TildeInModuleCat R M).map i.op s :=
  let ‚ü®V, hxV, iVU, f, g, hfg‚ü© := s.2 ‚ü®x, hx‚ü©
  ‚ü®V, hxV, iVU, f, g, fun y hyV => (hfg ‚ü®y, hyV‚ü©).1,
    Subtype.eq <| funext fun y => by
    simp only [isLocallyFraction_pred, LocalizedModule.mkLinearMap_apply, const_apply, res_apply]
    obtain ‚ü®h1, (h2 : g ‚Ä¢ s.1 ‚ü®y, _‚ü© = LocalizedModule.mk f 1)‚ü© := hfg y
    replace h2 : s.1 (iVU y) = LocalizedModule.mk f ‚ü®g, by exact h1‚ü© := by
      let x := s.1 (iVU y)
      change g ‚Ä¢ x = _ at h2
      change x = _
      clear_value x
      induction x using LocalizedModule.induction_on with
      | h a b =>
        rw [LocalizedModule.smul'_mk, LocalizedModule.mk_eq] at h2
        obtain ‚ü®c, hc‚ü© := h2
        refine LocalizedModule.mk_eq.mpr ‚ü®c, by simpa using hc‚ü©
    rw [h2]‚ü©


@[simp]
theorem res_const (f : M) (g : R) (U hu V hv i) :
    (TildeInModuleCat R M).map i (const R M f g U hu) = const R M f g V hv :=
  rfl

theorem res_const' (f : M) (g : R) (V hv) :
    (TildeInModuleCat R M).map (homOfLE hv).op (const R M f g (PrimeSpectrum.basicOpen g) fun _ => id) =
      const R M f g V hv :=
  rfl

@[simp]
theorem localizationToStalk_mk' (x : PrimeSpectrum.Top R) (f : M) (s : x.asIdeal.primeCompl) :
    localizationToStalk R M x (LocalizedModule.mk f s) =
      (TildeInModuleCat R M).germ (‚ü®x, s.2‚ü© : PrimeSpectrum.basicOpen (s : R))
        (const R M f s (PrimeSpectrum.basicOpen s) fun _ => id) := by
  simp only [localizationToStalk]
  erw [LocalizedModule.lift_mk]
  change (isUnit_toStalk R M x s).unit.inv _ = _
  apply_fun (isUnit_toStalk R M x s).unit.1 using
    (Module.End_isUnit_iff _ |>.1 (isUnit_toStalk R M x s)).injective
  rw [‚Üê LinearMap.mul_apply]
  simp only [IsUnit.unit_spec, Units.inv_eq_val_inv, IsUnit.mul_val_inv, LinearMap.one_apply,
    Module.algebraMap_end_apply]
  delta toStalk
  erw [comp_apply]
  rw [smul_germ]
  fapply TopCat.Presheaf.germ_ext
  ¬∑ exact PrimeSpectrum.basicOpen s
  ¬∑ exact s.2
  ¬∑ exact homOfLE le_top
  ¬∑ exact ùüô _
  simp only [op_id, CategoryTheory.Functor.map_id, LinearMapClass.map_smul, id_apply]
  refine Subtype.eq <| funext fun y => ?_
  change LocalizedModule.mk _ _ = _
  rw [smul_section_apply]
  simp only [Opens.coe_top, Quiver.Hom.unop_op, isLocallyFraction_pred,
    LocalizedModule.mkLinearMap_apply, const_apply]
  rw [LocalizedModule.smul'_mk, LocalizedModule.mk_eq]
  refine ‚ü®1, ?_‚ü©
  simp only [smul_comm, one_smul]
  rfl

@[simps]
noncomputable def stalkIso (x : PrimeSpectrum.Top R) :
    TopCat.Presheaf.stalk (TildeInModuleCat R M) x ‚âÖ
    ModuleCat.of R (LocalizedModule x.asIdeal.primeCompl M) where
  hom := stalkToFiberLinearMap R M x
  inv := localizationToStalk R M x
  hom_inv_id := by
    fapply TopCat.Presheaf.stalk_hom_ext
    intro U hxU
    ext s
    simp only [Category.comp_id]
    erw [comp_apply, comp_apply, stalkToFiberLinearMap_germ']
    obtain ‚ü®V, hxV, iVU, f, g, (hg : V ‚â§ PrimeSpectrum.basicOpen _), hs‚ü© :=
      exists_const _ _ _ s x hxU
    erw [‚Üê res_apply R M U V iVU s ‚ü®x, hxV‚ü©, ‚Üê hs, const_apply, localizationToStalk_mk']
    refine (TildeInModuleCat R M).germ_ext V hxV (homOfLE hg) iVU ?_
    dsimp
    erw [‚Üê hs, res_const']
  inv_hom_id := by
    ext x
    induction x using LocalizedModule.induction_on with
    | h m s =>
      simp only [ModuleCat.coe_comp, Function.comp_apply, localizationToStalk_mk',
        ModuleCat.id_apply]
      erw [stalkToFiberLinearMap_germ']
      simp

end Tilde

end AlgebraicGeometry
