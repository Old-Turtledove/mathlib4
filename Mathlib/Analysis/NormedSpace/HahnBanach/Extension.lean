/-
Copyright (c) 2020 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov, Heather Macbeth
-/
import Mathlib.Analysis.Convex.Cone.Extension
import Mathlib.Analysis.NormedSpace.RCLike
import Mathlib.Analysis.NormedSpace.Extend
import Mathlib.Analysis.RCLike.Lemmas

/-!
# Extension Hahn-Banach theorem

In this file we prove the analytic Hahn-Banach theorem. For any continuous linear function on a
subspace, we can extend it to a function on the entire space without changing its norm.

We prove
* `Real.exists_extension_norm_eq`: Hahn-Banach theorem for continuous linear functions on normed
  spaces over `‚Ñù`.
* `exists_extension_norm_eq`: Hahn-Banach theorem for continuous linear functions on normed spaces
  over `‚Ñù` or `‚ÑÇ`.

In order to state and prove the corollaries uniformly, we prove the statements for a field `ùïú`
satisfying `RCLike ùïú`.

In this setting, `exists_dual_vector` states that, for any nonzero `x`, there exists a continuous
linear form `g` of norm `1` with `g x = ‚Äñx‚Äñ` (where the norm has to be interpreted as an element
of `ùïú`).

-/


universe u v

namespace Real

variable {E : Type*} [SeminormedAddCommGroup E] [NormedSpace ‚Ñù E]

/-- **Hahn-Banach theorem** for continuous linear functions over `‚Ñù`.
See also `exists_extension_norm_eq` in the root namespace for a more general version
that works both for `‚Ñù` and `‚ÑÇ`. -/
theorem exists_extension_norm_eq (p : Subspace ‚Ñù E) (f : p ‚ÜíL[‚Ñù] ‚Ñù) :
    ‚àÉ g : E ‚ÜíL[‚Ñù] ‚Ñù, (‚àÄ x : p, g x = f x) ‚àß ‚Äñg‚Äñ = ‚Äñf‚Äñ := by
  rcases exists_extension_of_le_sublinear ‚ü®p, f‚ü© (fun x => ‚Äñf‚Äñ * ‚Äñx‚Äñ)
      (fun c hc x => by simp only [norm_smul c x, Real.norm_eq_abs, abs_of_pos hc, mul_left_comm])
      (fun x y => by -- Porting note: placeholder filled here
        rw [‚Üê left_distrib]
        exact mul_le_mul_of_nonneg_left (norm_add_le x y) (@norm_nonneg _ _ f))
      fun x => le_trans (le_abs_self _) (f.le_opNorm _) with ‚ü®g, g_eq, g_le‚ü©
  set g' :=
    g.mkContinuous ‚Äñf‚Äñ fun x => abs_le.2 ‚ü®neg_le.1 <| g.map_neg x ‚ñ∏ norm_neg x ‚ñ∏ g_le (-x), g_le x‚ü©
  refine ‚ü®g', g_eq, ?_‚ü©
  apply le_antisymm (g.mkContinuous_norm_le (norm_nonneg f) _)
  refine f.opNorm_le_bound (norm_nonneg _) fun x => ?_
  dsimp at g_eq
  rw [‚Üê g_eq]
  apply g'.le_opNorm

end Real

section RCLike

-- open RCLike

class IsRorC (ùïú : Type*) [hk : NormedField ùïú] : Prop :=
  out : ‚àÉ h : RCLike ùïú, h.toNormedField = hk

instance {ùïú : Type*} [h : RCLike ùïú] : IsRorC ùïú := ‚ü®‚ü®h, rfl‚ü©‚ü©

instance : IsRorC ‚Ñù := by infer_instance

suppress_compilation

/-- A copy of an `RCLike` field in which the `NormedField` field is adjusted to be become defeq
to a propeq one. -/
def RCLike.copy {ùïú : Type*} (h : RCLike ùïú)  (hk : NormedField ùïú)
    (h'' : h.toNormedField = hk) : RCLike ùïú where
  __ := hk
  lt_norm_lt := fun x y hx hy ‚Ü¶ by simpa [h''] using h.lt_norm_lt x y hx hy
  -- star fields
  star := (@StarMul.toInvolutiveStar _ (_) (@StarRing.toStarMul _ (_) h.toStarRing)).star
  star_involutive :=
    @star_involutive _ (@StarMul.toInvolutiveStar _ (_) (@StarRing.toStarMul _ (_) h.toStarRing))
  star_mul x y := by
    convert @star_mul _ (_)  (@StarRing.toStarMul _ (_) h.toStarRing) x y <;> simp only [h'']
  star_add x y := by
    convert @StarRing.star_add _ (_) h.toStarRing x y <;> simp only [h'']
  smul := (@Algebra.toSMul _ _ _ (_) (@NormedAlgebra.toAlgebra _ _ _ (_) h.toNormedAlgebra)).smul
  -- algebra fields
  toFun := @Algebra.toRingHom _ _ _ (_) (@NormedAlgebra.toAlgebra _ _ _ (_) h.toNormedAlgebra)
  map_one' := sorry /-by
    let Z := (@Algebra.toRingHom _ _ _ (_) (@NormedAlgebra.toAlgebra _ _ _ (_) h.toNormedAlgebra))
    convert @OneHom.map_one' _ _ _ (_) (@MonoidHom.toOneHom _ _ _ (_)
      (@RingHom.toMonoidHom _ _ _ (_) Z))
    simp only [h'']-/
  map_mul' x y := sorry /-by
    let Z := (@Algebra.toRingHom _ _ _ (_) (@NormedAlgebra.toAlgebra _ _ _ (_) h.toNormedAlgebra))
    convert @MulHom.map_mul' _ _ _ (_) (@MonoidHom.toMulHom _ _ _ (_)
      (@RingHom.toMonoidHom _ _ _ (_) Z)) x y <;>
    simp only [h'']-/
  map_zero' := sorry /-by
    let Z := (@Algebra.toRingHom _ _ _ (_) (@NormedAlgebra.toAlgebra _ _ _ (_) h.toNormedAlgebra))
    convert @ZeroHom.map_zero' _ _ _ (_) (@AddMonoidHom.toZeroHom _ _ _ (_)
      (@RingHom.toAddMonoidHom _ _ _ (_) Z)) <;>
    simp only [h'']-/
  map_add' x y := sorry /-by
    let Z := (@Algebra.toRingHom _ _ _ (_) (@NormedAlgebra.toAlgebra _ _ _ (_) h.toNormedAlgebra))
    convert @AddHom.map_add' _ _ _ (_) (@AddMonoidHom.toAddHom _ _ _ (_)
      (@RingHom.toAddMonoidHom _ _ _ (_) Z)) x y <;>
    simp only [h'']-/
  commutes' r x := sorry /-by
    convert @Algebra.commutes' _ _ _ (_) (@NormedAlgebra.toAlgebra _ _ _ (_) h.toNormedAlgebra) r x
    <;> simp only [h''] -/
  smul_def' r x := sorry /-by
    convert @Algebra.smul_def' _ _ _ (_) (@NormedAlgebra.toAlgebra _ _ _ (_) h.toNormedAlgebra) r x
    <;> simp only [h'']-/
  norm_smul_le r x := by
    convert @NormedAlgebra.norm_smul_le _ _ _ (_) h.toNormedAlgebra r x <;> simp only [h'']
  complete := by
    convert @CompleteSpace.complete _ (_) h.toCompleteSpace <;> simp only [h'']
  -- RCLike fields
  re :=
    { toFun := h.re
      map_zero' := by
        convert @ZeroHom.map_zero' _ _ (_) _ (@AddMonoidHom.toZeroHom _ _ (_) _ h.re)
        simp only [h'']
      map_add' := by
        intro x y
        convert @AddHom.map_add' _ _ (_) _ (@AddMonoidHom.toAddHom _ _ (_) _ h.re) x y
        <;> simp only [h''] }
  im :=
    { toFun := h.im
      map_zero' := by
        convert @ZeroHom.map_zero' _ _ (_) _ (@AddMonoidHom.toZeroHom _ _ (_) _ h.im)
        simp only [h'']
      map_add' := by
        intro x y
        convert @AddHom.map_add' _ _ (_) _ (@AddMonoidHom.toAddHom _ _ (_) _ h.im) x y
        <;> simp only [h''] }
  I := h.I
  I_re_ax := sorry -- by convert h.I_re_ax <;> simp only [h'']
  I_mul_I_ax := sorry -- by convert h.I_mul_I_ax <;> simp only [h'']
  re_add_im_ax z := sorry -- by convert h.re_add_im_ax z <;> simp only [h'']
  ofReal_re_ax r := sorry -- by convert h.ofReal_re_ax r <;> simp only [h'']
  ofReal_im_ax r := sorry -- by convert h.ofReal_im_ax r <;> simp only [h'']
  mul_re_ax z w := by convert h.mul_re_ax z w <;> simp only [h'']
  mul_im_ax z w := by convert h.mul_im_ax z w <;> simp only [h'']
  conj_re_ax z := by convert h.conj_re_ax z <;> simp only [h'']
  conj_im_ax z := by convert h.conj_im_ax z <;> simp only [h'']
  conj_I_ax := by convert h.conj_I_ax <;> simp only [h'']
  norm_sq_eq_def_ax z := by convert h.norm_sq_eq_def_ax z <;> simp only [h'']
  mul_im_I_ax := sorry
  le_iff_re_im := sorry
  toPartialOrder := h.toPartialOrder
  toDecidableEq := h.toDecidableEq
























#exit

  star :=
  star_involutive :=
  #exit

  star_mul', 'star_add', 'smul', 'toFun', 'map_one'', 'map_mul'', 'map_zero'', 'map_add'', 'commutes'', 'smul_def'', 'norm_smul_le', 'complete', 're', 'im', 'I', 'I_re_ax', 'I_mul_I_ax', 're_add_im_ax', 'ofReal_re_ax', 'ofReal_im_ax', 'mul_re_ax', 'mul_im_ax', 'conj_re_ax', 'conj_im_ax', 'conj_I_ax', 'norm_sq_eq_def_ax', 'mul_im_I_ax', 'le_iff_re_im'



#exit


  let A : DenselyNormedField ùïú :=
  { toNormedField := hk
    lt_norm_lt := fun x y hx hy ‚Ü¶ by simpa [h''] using h.lt_norm_lt x y hx hy }
  let B : StarRing ùïú where
    __ := hk


#exit

  refine
  { toDenselyNormedField := A


  }


#exit

variable {ùïú : Type*} [RCLike ùïú] {E F : Type*}
  [SeminormedAddCommGroup E] [NormedSpace ùïú E]
  [NormedAddCommGroup F] [NormedSpace ùïú F]

/-- **Hahn-Banach theorem** for continuous linear functions over `ùïú` satisfying `RCLike ùïú`. -/
theorem exists_extension_norm_eq (p : Subspace ùïú E) (f : p ‚ÜíL[ùïú] ùïú) :
    ‚àÉ g : E ‚ÜíL[ùïú] ùïú, (‚àÄ x : p, g x = f x) ‚àß ‚Äñg‚Äñ = ‚Äñf‚Äñ := by
  letI : Module ‚Ñù E := RestrictScalars.module ‚Ñù ùïú E
  letI : IsScalarTower ‚Ñù ùïú E := RestrictScalars.isScalarTower _ _ _
  letI : NormedSpace ‚Ñù E := NormedSpace.restrictScalars _ ùïú _
  -- Let `fr: p ‚ÜíL[‚Ñù] ‚Ñù` be the real part of `f`.
  let fr := reCLM.comp (f.restrictScalars ‚Ñù)
  -- Use the real version to get a norm-preserving extension of `fr`, which
  -- we'll call `g : E ‚ÜíL[‚Ñù] ‚Ñù`.
  rcases Real.exists_extension_norm_eq (p.restrictScalars ‚Ñù) fr with ‚ü®g, ‚ü®hextends, hnormeq‚ü©‚ü©
  -- Now `g` can be extended to the `E ‚ÜíL[ùïú] ùïú` we need.
  refine ‚ü®g.extendToùïú, ?_‚ü©
  -- It is an extension of `f`.
  have h : ‚àÄ x : p, g.extendToùïú x = f x := by
    intro x
    -- This used to be `rw`, but we need `erw` after leanprover/lean4#2644
    erw [ContinuousLinearMap.extendToùïú_apply, ‚Üê Submodule.coe_smul, hextends, hextends]
    have :
        (fr x : ùïú) - I * ‚Üë(fr ((I : ùïú) ‚Ä¢ x)) = (re (f x) : ùïú) - (I : ùïú) * re (f ((I : ùïú) ‚Ä¢ x)) := by
      rfl
    -- This used to be `rw`, but we need `erw` after leanprover/lean4#2644
    erw [this]
    apply ext
    ¬∑ simp only [add_zero, Algebra.id.smul_eq_mul, I_re, ofReal_im, AddMonoidHom.map_add, zero_sub,
        I_im', zero_mul, ofReal_re, eq_self_iff_true, sub_zero, mul_neg, ofReal_neg,
        mul_re, mul_zero, sub_neg_eq_add, ContinuousLinearMap.map_smul]
    ¬∑ simp only [Algebra.id.smul_eq_mul, I_re, ofReal_im, AddMonoidHom.map_add, zero_sub, I_im',
        zero_mul, ofReal_re, mul_neg, mul_im, zero_add, ofReal_neg, mul_re,
        sub_neg_eq_add, ContinuousLinearMap.map_smul]
  -- And we derive the equality of the norms by bounding on both sides.
  refine ‚ü®h, le_antisymm ?_ ?_‚ü©
  ¬∑ calc
      ‚Äñg.extendToùïú‚Äñ = ‚Äñg‚Äñ := g.norm_extendToùïú
      _ = ‚Äñfr‚Äñ := hnormeq
      _ ‚â§ ‚ÄñreCLM‚Äñ * ‚Äñf‚Äñ := ContinuousLinearMap.opNorm_comp_le _ _
      _ = ‚Äñf‚Äñ := by rw [reCLM_norm, one_mul]
  ¬∑ exact f.opNorm_le_bound g.extendToùïú.opNorm_nonneg fun x => h x ‚ñ∏ g.extendToùïú.le_opNorm x

open FiniteDimensional

/-- Corollary of the **Hahn-Banach theorem**: if `f : p ‚Üí F` is a continuous linear map
from a submodule of a normed space `E` over `ùïú`, `ùïú = ‚Ñù` or `ùïú = ‚ÑÇ`,
with a finite dimensional range,
then `f` admits an extension to a continuous linear map `E ‚Üí F`.

Note that contrary to the case `F = ùïú`, see `exists_extension_norm_eq`,
we provide no estimates on the norm of the extension.
-/
lemma ContinuousLinearMap.exist_extension_of_finiteDimensional_range {p : Submodule ùïú E}
    (f : p ‚ÜíL[ùïú] F) [FiniteDimensional ùïú (LinearMap.range f)] :
    ‚àÉ g : E ‚ÜíL[ùïú] F, f = g.comp p.subtypeL := by
  set b := finBasis ùïú (LinearMap.range f)
  set e := b.equivFunL
  set fi := fun i ‚Ü¶ (LinearMap.toContinuousLinearMap (b.coord i)).comp
    (f.codRestrict _ <| LinearMap.mem_range_self _)
  choose gi hgf _ using fun i ‚Ü¶ exists_extension_norm_eq p (fi i)
  use (LinearMap.range f).subtypeL.comp <| e.symm.toContinuousLinearMap.comp (.pi gi)
  ext x
  simp [fi, e, hgf]

/-- A finite dimensional submodule over `‚Ñù` or `‚ÑÇ` is `Submodule.ClosedComplemented`. -/
lemma Submodule.ClosedComplemented.of_finiteDimensional (p : Submodule ùïú F)
    [FiniteDimensional ùïú p] : p.ClosedComplemented :=
  let ‚ü®g, hg‚ü© := (ContinuousLinearMap.id ùïú p).exist_extension_of_finiteDimensional_range
  ‚ü®g, DFunLike.congr_fun hg.symm‚ü©

end RCLike

section DualVector

variable (ùïú : Type v) [RCLike ùïú]
variable {E : Type u} [NormedAddCommGroup E] [NormedSpace ùïú E]

open ContinuousLinearEquiv Submodule

open scoped Classical

theorem coord_norm' {x : E} (h : x ‚â† 0) : ‚Äñ(‚Äñx‚Äñ : ùïú) ‚Ä¢ coord ùïú x h‚Äñ = 1 := by
  #adaptation_note
  /--
  `set_option maxSynthPendingDepth 2` required after https://github.com/leanprover/lean4/pull/4119
  Alternatively, we can add:
  ```
  let X : SeminormedAddCommGroup (‚Ü•(span ùïú {x}) ‚ÜíL[ùïú] ùïú) := inferInstance
  have : BoundedSMul ùïú (‚Ü•(span ùïú {x}) ‚ÜíL[ùïú] ùïú) := @NormedSpace.boundedSMul ùïú _ _ X _
  ```
  -/
  set_option maxSynthPendingDepth 2 in
  rw [norm_smul (Œ± := ùïú) (x := coord ùïú x h), RCLike.norm_coe_norm, coord_norm,
    mul_inv_cancel‚ÇÄ (mt norm_eq_zero.mp h)]

/-- Corollary of Hahn-Banach. Given a nonzero element `x` of a normed space, there exists an
    element of the dual space, of norm `1`, whose value on `x` is `‚Äñx‚Äñ`. -/
theorem exists_dual_vector (x : E) (h : x ‚â† 0) : ‚àÉ g : E ‚ÜíL[ùïú] ùïú, ‚Äñg‚Äñ = 1 ‚àß g x = ‚Äñx‚Äñ := by
  let p : Submodule ùïú E := ùïú ‚àô x
  let f := (‚Äñx‚Äñ : ùïú) ‚Ä¢ coord ùïú x h
  obtain ‚ü®g, hg‚ü© := exists_extension_norm_eq p f
  refine ‚ü®g, ?_, ?_‚ü©
  ¬∑ rw [hg.2, coord_norm']
  ¬∑ calc
      g x = g (‚ü®x, mem_span_singleton_self x‚ü© : ùïú ‚àô x) := by rw [coe_mk]
      _ = ((‚Äñx‚Äñ : ùïú) ‚Ä¢ coord ùïú x h) (‚ü®x, mem_span_singleton_self x‚ü© : ùïú ‚àô x) := by rw [‚Üê hg.1]
      _ = ‚Äñx‚Äñ := by simp

/-- Variant of Hahn-Banach, eliminating the hypothesis that `x` be nonzero, and choosing
    the dual element arbitrarily when `x = 0`. -/
theorem exists_dual_vector' [Nontrivial E] (x : E) : ‚àÉ g : E ‚ÜíL[ùïú] ùïú, ‚Äñg‚Äñ = 1 ‚àß g x = ‚Äñx‚Äñ := by
  by_cases hx : x = 0
  ¬∑ obtain ‚ü®y, hy‚ü© := exists_ne (0 : E)
    obtain ‚ü®g, hg‚ü© : ‚àÉ g : E ‚ÜíL[ùïú] ùïú, ‚Äñg‚Äñ = 1 ‚àß g y = ‚Äñy‚Äñ := exists_dual_vector ùïú y hy
    refine ‚ü®g, hg.left, ?_‚ü©
    simp [hx]
  ¬∑ exact exists_dual_vector ùïú x hx

/-- Variant of Hahn-Banach, eliminating the hypothesis that `x` be nonzero, but only ensuring that
    the dual element has norm at most `1` (this can not be improved for the trivial
    vector space). -/
theorem exists_dual_vector'' (x : E) : ‚àÉ g : E ‚ÜíL[ùïú] ùïú, ‚Äñg‚Äñ ‚â§ 1 ‚àß g x = ‚Äñx‚Äñ := by
  by_cases hx : x = 0
  ¬∑ refine ‚ü®0, by simp, ?_‚ü©
    symm
    simp [hx]
  ¬∑ rcases exists_dual_vector ùïú x hx with ‚ü®g, g_norm, g_eq‚ü©
    exact ‚ü®g, g_norm.le, g_eq‚ü©

end DualVector
